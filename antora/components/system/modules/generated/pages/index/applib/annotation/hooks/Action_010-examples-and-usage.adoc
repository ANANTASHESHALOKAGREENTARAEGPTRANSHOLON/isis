:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:page-partial:


== Examples

For example:

[source,java]
----
public class ToDoItem {
    public static class CompletedEvent extends ActionDomainEvent<ToDoItem> { }
    @Action(
        commandPublishing=Publishing.ENABLED,
        commandExecuteIn=CommandExecuteIn.FOREGROUND,          // <.>
        commandPersistence=CommandPersistence.NOT_PERSISTED,   // <.>
        domainEvent=CompletedEvent.class,
        hidden = Where.NOWHERE,                                // <.>
        executionPublishing = Publishing.ENABLED,
        semantics = SemanticsOf.IDEMPOTENT
    )
    public ToDoItem completed() { /* ... */ }
}
----
<.> default value, so could be omitted
<.> default value, so could be omitted
<.> default value, so could be omitted


== Usage Notes

=== Associating actions with properties and collections

The `associateWith` element allows an action to be associated with other properties or collections of the same domain object.
The optional `associateWithSequence` element specifies the order of the action in the UI.

For example, an `Order` could have a collection of ``OrderItem``s, and might provide actions to add and remove items:

[source,java]
----
public class Order {

    @Getter @Setter
    @Collection
    private final SortedSet<OrderItem> items = ...

    @Action(
        associateWith="items",                      // <.>
        associateWithSequence="1" )                 // <.>
    public Order addItem(Product p, int quantity) {
        // ...
    }

    @Action(
        associateWith="items",                      // <.>
        associateWithSequence="2" )                 // <.>
    public Order removeItem(OrderItem item) {
        // ...
    }

    // ...
}
----

<.> matches the name of the collection
<.> first action in the list of all associated actions
<.> matches the name of the collection
<.> second action in the list of all associated actions

These actions - `addItem()` and `removeItem()` can be thought of as associated with with the `items` collection because that is the state that they primarily affect.

In the user interface associated actions are rendered close to the member to which they relate.

[NOTE]
====
The same effect can be accomplished using `@MemberOrder` or with the `.layout.xml` file.
====

==== Inferred Defaults and Choices

If an action is associated with a collection, then any scalar or collection parameter of the action that is the same type as that collection will automatically have a list of choices provided for it, being the items of the associated collection.

This is only done provided that there isn't already an explicit `choicesNXxx()` or `autoCompleteNXxx()` supporting method.
However, this list of choices _does_ take priority over any choices that are inferred from the parameter type itself (as per either an `@DomainObject(autoCompleteRepository=...)` or `@DomainObject(bounded=...)`).

In addition, if the action has a collection parameter of the same type as the associated collection, then the Wicket viewer will render the collection with checkboxes.
The user can use these checkboxes can be used to select the items of the action parameter.

For example, suppose we have a "removeItems(...)" action:

[source,java]
----
import lombok.Getter;
import lombok.Setter;

public class Order {

    @Getter @Setter
    @Collection
    private final SortedSet<OrderItem> items = ...

    @Action(
        associateWith="items",
        associateWithSequence="2" )
    public Order removeItems(SortedSet<OrderItem> items) {
        // ...
    }

    // ...
}
----

The Wicket viewer will then render the "items" collection with checkboxes, and any selected items will be used as the pre-selected set of items if the action is invoked.

=== Command Processing

Every action invocation (and xref:system:generated:index/applib/annotation/Property.adoc#commandPublishing[property edit] for that matter) is normally reified into a concrete `Command` object, basically a wrapper around the xref:schema:cmd.adoc[CommandDto] that also captures some timing metrics about the execution as well as the outcome.

The main uses cases are:

* as a means to allow asynchronous child commands to be executed, using the xref:system:generated:index/applib/services/wrapper/WrapperFactory.adoc[WrapperFactory] service;

* as a means to audit (persist) commands, by implementing the xref:system:generated:index/applib/services/publishing/spi/CommandSubscriber.adoc[CommandSubscriber] SPI.
+
The xref:extensions:command-log:about.adoc[Command Log] extension _does_ provide such an implementation.
+
TIP: Another option to achieve this is to use the xref:system:generated:index/applib/services/publishing/spi/ExecutionSubscriber.adoc[ExecutionSubscriber] SPI.

* to replay commands onto a secondary system, for regression testing.
+
This is implemented by the xref:extensions:command-replay:about.adoc[Command Replay] extension, working in conjunction with the xref:extensions:command-log:about.adoc[Command Log] extension.


==== CommandDtoProcessor implementations

The `commandDtoProcessor` element allows an implementation of `CommandDtoProcessor` to be specified.
This interface has the following API:

[source,java]
----
public interface CommandDtoProcessor {
    CommandDto process(             // <.>
            CommandDto dto);        // <.>
}
----
<.> The returned `CommandDto`.
This will typically be the `CommandDto` passed in, but may be supplemented in some way.
<.> The `CommandDto` obtained already from the `Command`.

This interface is used by the framework-provided implementations of xref:system:generated:index/applib/services/conmap/ContentMappingService.adoc[ContentMappingService] for the REST API, allowing ``Command``s implementations that also implement `CommandWithDto` to be further customised as they are serialized out.
The primary use case for this capability is in support of primary/secondary replication.

* on the primary, ``Command``s are serialized to XML.
This includes the identity of the target object and the argument values of all parameters.

+
[IMPORTANT]
====
Any ``Blob``s and ``Clob``s are deliberately excluded from this XML (they are instead stored as references).
This is to prevent the storage requirements for `Command` from becoming excessive.
A `CommandDtoProcessor` can be provided to re-attach blob information if required.
====

* replaying ``Command``s requires this missing parameter information to be reinstated.
The `CommandDtoProcessor` therefore offers a hook to dynamically re-attach the missing `Blob` or `Clob` argument.

As a special case, returning `null` means that the command's DTO is effectively excluded when retrieving the list of commands.
If replicating from master to slave, this effectively allows certain commands to be ignored.
The `CommandDtoProcessor.Null` class provides a convenience implementation for this requirement.

[NOTE]
====
If `commandDtoProcessor()` is specified, then `commandPublishing()` is assumed to be ENABLED.
====

==== Example implementation

Consider the following method:

[source,java]
----
@Action(
    domainEvent = IncomingDocumentRepository.UploadDomainEvent.class,
    commandDtoProcessor = DeriveBlobArg0FromReturnedDocument.class
)
public Document upload(final Blob blob) {
    final String name = blob.getName();
    final DocumentType type = DocumentTypeData.INCOMING.findUsing(documentTypeRepository);
    final ApplicationUser me = meService.me();
    String atPath = me != null ? me.getAtPath() : null;
    if (atPath == null) {
        atPath = "/";
    }
    return incomingDocumentRepository.upsertAndArchive(type, atPath, name, blob);
}
----

The `Blob` argument will not be persisted in the memento of the `Command`, but the information is implicitly available in the `Document` that is returned by the action.
The `DeriveBlobArg0FromReturnedDocument` processor retrieves this information and dynamically adds:

[source,java]
----
public class DeriveBlobArg0FromReturnedDocument
        extends CommandDtoProcessorForActionAbstract {

    @Override
    public CommandDto process(Command command, CommandDto commandDto) {
        final Bookmark result = commandWithDto.getResult();
        if(result == null) {
            return commandDto;
        }
        try {
            final Document document = bookmarkService.lookup(result, Document.class);
            if (document != null) {
                ParamDto paramDto = getParamDto(commandDto, 0);
                CommonDtoUtils.setValueOn(paramDto, ValueType.BLOB, document.getBlob(), bookmarkService);
            }
        } catch(Exception ex) {
            return commandDto;
        }
        return commandDto;
    }
    @Inject
    BookmarkService bookmarkService;
}
----

==== Null implementation

The null implementation can be used to simply indicate that no DTO should be returned for a `Command`.
The effect is to ignore it for replay purposes:

[source,xml]
----
pubc interface CommandDtoProcessor {
    ...
    class Null implements CommandDtoProcessor {
        public CommandDto process(Command command, CommandDto commandDto) {
            return null;
        }
    }
}
----


=== Domain events

Whenever a domain object (or list of domain objects) is to be rendered, the framework fires off multiple domain events for every property, collection and action of the domain object.
In the cases of the domain object's actions, the events that are fired are:

* hide phase: to check that the action is visible (has not been hidden)
* disable phase: to check that the action is usable (has not been disabled)
* validate phase: to check that the action's arguments are valid
* pre-execute phase: before the invocation of the action
* post-execute: after the invocation of the action

Subscribers subscribe through the xref:system:generated:index/applib/services/eventbus/EventBusService.adoc[`EventBusService`] and can influence each of these phases.

By default the event raised is `ActionDomainEvent.Default`.
For example:

[source,java]
----
public class ToDoItem {

    @Action()
    public ToDoItem completed() {
        // ...
    }
    ...
}
----

The xref:system:generated:index/applib/annotation/Action.adoc#domainEvent[domainEvent()] element allows a custom subclass to be emitted allowing more precise subscriptions (to those subclasses) to be defined instead.

For example:

[source,java]
----
public class ToDoItem {
    public static class CompletedEvent extends ActionDomainEvent<ToDoItem> { }  // <1>
    @Action(domainEvent=CompletedEvent.class)
    public ToDoItem completed() { /* ... */ }
}
----

The benefit is that subscribers can be more targeted as to the events that they subscribe to.

[NOTE]
====
The framework provides no-arg constructor and will initialize the domain event using (non-API) setters rather than through the constructor.
This substantially reduces the boilerplate required in subclasses because no explicit constructor is required.
====

==== Subscribers

Subscribers (which must be domain services) subscribe to events posted through the xref:system:generated:index/applib/services/eventbus/EventBusService.adoc[`EventBusService`].

Subscribers can be either coarse-grained (if they subscribe to the top-level event type):

[source,java]
----
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;

@Service
public class SomeSubscriber {
    @EventListener(ActionDomainEvent.class)
    public void on(ActionDomainEvent ev) {
        ...
    }
}
----

or can be fine-grained (by subscribing to specific event subtypes):

[source,java]
----
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;

@Service
public class SomeSubscriber {
    @EventListener(ToDoItem.CompletedEvent.class)
    public void on(ToDoItem.CompletedEvent ev) {
        ...
    }
}
----

The subscriber's method is called (up to) 5 times:

* whether to veto visibility (hide)
* whether to veto usability (disable)
* whether to veto execution (validate)
* steps to perform prior to the action being invoked
* steps to perform after the action has been invoked

The subscriber can distinguish these by calling `ev.getEventPhase()`.
Thus the general form is:

[source,java]
----
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;

@Service
public class SomeSubscriber {

    @EventListener(ActionDomainEvent.class)
    public void on(ActionDomainEvent ev) {
        switch(ev.getEventPhase()) {

            case HIDE:                      // <.>
                break;
            case DISABLE:                   // <.>
                break;
            case VALIDATE:                  // <.>
                break;

            case EXECUTING:
                break;
            case EXECUTED:
                break;
        }
    }
}
----

<.> call `ev.hide()` or `ev.veto("")` to hide the action

<.> call `ev.disable("...")` or `ev.veto("...")` to disable the action

<.> call ev.invalidate("...") or ev.veto("...") if action arguments are invalid

It is also possible to abort the transaction during the executing or executed phases by throwing an exception.
If the exception is a subtype of `RecoverableException` then the exception will be rendered as a user-friendly warning (eg Growl/toast) rather than an error.

==== Default, Doop and Noop events

If the xref:system:generated:index/applib/annotation/Action.adoc#domainEvent[domainEvent()] element is not explicitly specified (is left as its default value, `ActionDomainEvent.Default`), then the framework will, by default, post an event.

If this is not required, then the `isis.reflector.facet.actionAnnotation.domainEvent.postForDefault` configuration property can be set to "false"; this will disable posting.

On the other hand, if the `domainEvent` has been explicitly specified to some subclass, then an event will be posted.
The framework provides `ActionDomainEvent.Doop` as such a subclass, so setting the `domainEvent` element to this class will ensure that the event to be posted, irrespective of the configuration property setting.

And, conversely, the framework also provides `ActionDomainEvent.Noop`; if `domainEvent` element is set to this class, then no event will be posted.

=== Class-level default

Sometimes a subscriber is interested in all of the actions of a given class, though not any individual action.
A common use case is to hide or disable all actions for some particular object for some particular user group.

For this use, the default action domain event can be annotated using `@DomainObject`:

[source,java]
----
@DomainObject(
    actionDomainEvent=ToDoItem.ActionDomainEvent.class
)
public class ToDoItem {
    public static class ActionDomainEvent extends
        org.apache.isis.applib.events.domain.ActionDomainEvent<Object> { }
    // ...

    public void updateDescription(final String description) {
        this.description = description;
    }

}
----


==== Raising events programmatically

Normally events are only raised for interactions through the UI.
However, events can be raised programmatically either by calling the xref:system:generated:index/applib/services/eventbus/EventBusService.adoc[EventBusService] API directly, or by emulating the UI by wrapping the target object using the xref:system:generated:index/applib/services/wrapper/WrapperFactory.adoc[WrapperFactory] domain service.



=== Execution Publishing

The xref:system:generated:index/applib/annotation/Action.adoc#executionPublishing[executionPublishing()] element determines whether and how an action invocation is published via the registered implementation of xref:system:generated:index/applib/services/publishing/spi/ExecutionSubscriber.adoc[ExecutionSubscriber].

A common use case is to notify external "downstream" systems of changes in the state of the Apache Isis application.


The xref:refguide:config:sections/isis.applib.adoc#isis.applib.annotation.property.execution-publishing[`isis.applib.annotation.property.execution-publishing`] configuration property is used to determine the whether the action is published:

* `all`
+
all action invocations are published

* `ignoreSafe` (or `ignoreQueryOnly`)
+
invocations of actions with safe (read-only) semantics are ignored, but actions which may modify data are not ignored

* `none`
+
no action invocations are published

If there is no configuration property in `application.properties` then publishing is automatically enabled.

This default can be overridden on an action-by-action basis; if `executionPublishing()` is set to `ENABLED` then the action invocation is published irrespective of the configured value; if set to `DISABLED` then the action invocation is _not_ published, again irrespective of the configured value.

For example:

[source,java]
----
public class Order {
    @Action(executionPublishing=Publishing.ENABLED)    // <.>
    public Invoice generateInvoice(...) {
        // ...
    }
}
----

<.> because set to enabled, will be published irrespective of the configured value.


=== Deployment modes

By default actions are available irrespective of the xref:refguide:config:about.adoc#deployment-types[deployment mode].
The xref:system:generated:index/applib/annotation/Action.adoc#restrictTo[restrictTo()] element specifies whether the action should instead be restricted to only available in prototyping mode.

For example:

[source,java]
----
public class Customer {

    @Action
    public Order placeNewOrder() {
        // ...
    }
    @Action(semantics=SemanticsOf.SAFE)
    public List<Order> listRecentOrders() {
        // ...
    }

    @Action(restrictTo=RestrictTo.PROTOTYPING)      // <.>
    public List<Order> listAllOrders() {
        // ...
    }
    ...
}
----

<.> Only visible in prototype mode.

In this case the listing of all orders (in the `listAllOrders()` action) probably doesn't make sense for production; there could be thousands or millions.
However, it would be useful to disaply how for a test or demo system where there are only a handful of orders.


=== Action Semantics


The xref:system:generated:index/applib/annotation/Action.adoc#semantics[semantics()] element describes whether the invocation modifies state of the system, and if so whether it does so idempotently.
If the action invocation does _not_ modify the state of the system, in other words is safe, then it also can beused to specify whether the results of the action can be cached automatically for the remainder of the request.

The `semantics` element was originally introduced for the xref:vro:ROOT:about.adoc[RestfulObjects viewer] in order that action invocations could be using the appropriate `HTTP` verb (`GET`, `PUT` and `POST`).

The table below summarizes the semantics:

[cols="2,1,3,1",options="header"]
|===
| Semantic
| Changes state
| Effect of multiple calls
| HTTP verb +
(Restful Objects)

| `SAFE_AND_REQUEST_CACHEABLE`
| No
| Will always return the same result each time invoked (within a given request scope)
| `GET`

| `SAFE`
| No
| Might result in different results each invocation
| `GET`

| `IDEMPOTENT` +
`IDEMPOTENT_ARE_YOU_SURE`
| Yes
| Will make no further changes if called multiple times (eg sets a property or adds to a `Set`). +
The "are you sure" variant requires that the user must explicitly confirm the action.
| `PUT`

| `NON_IDEMPOTENT` +
`NON_IDEMPOTENT_ARE_YOU_SURE`
| Yes
| Might change the state of the system each time called (eg increments a counter or adds to a `List`). +
The "are you sure" variant requires that the user must explicitly confirm the action.
| `POST`

|===

The actions' semantics are also used by the core runtime as part of the in-built concurrency checkng; invocation of a safe action (which includes request-cacheable) does _not_ perform a concurrency check, whereas non-safe actions _do_ perform a concurrency check.

For example:

[source,java]
----
public class Customer {

    @Action(semantics=SemanticsOf.SAFE_AND_REQUEST_CACHEABLE)
    public CreditRating checkCredit() {
        // ...
    }

    @Action(semantics=SemanticsOf.IDEMPOTENT)
    public void changeOfAddress(Address address) {
        // ...
    }

    @Action(semantics=SemanticsOf.NON_IDEMPOTENT)
    public Order placeNewOrder() {
        // ...
    }

    // ...
}
----

Actions that are safe and request-cacheable automatically use the xref:system:generated:index/applib/services/queryresultscache/QueryResultsCache.adoc[`QueryResultsCache`] service to cache the result of the method.
Note though that the results of this caching will only be apparent if the action is invoked from another method using the xref:system:generated:index/applib/services/wrapper/WrapperFactory.adoc[WrapperFactory] service.


=== Collection type

The xref:system:generated:index/applib/annotation/Action.adoc#typeOf[typeOf()] element specifies the expected type of an element returned by the action (returning a collection), when for whatever reason the type cannot be inferred from the generic type, or to provide a hint about the actual run-time (as opposed to compile-time) type.

For example:

[source,java]
----
public void AccountService {

    @Action(typeOf=Customer.class)
    public List errantAccounts() {
        return customers.allNewCustomers();
    }
    ...

    @Inject CustomerRepository customers;
}
----

In general we recommend that you use generics instead, eg `List<Customer>`.




== Related SPIs

* xref:system:generated:index/applib/services/publishing/spi/CommandSubscriber.adoc[CommandSubscriber] SPI
+
foractions with xref:system:generated:index/applib/annotation/Action.adoc#commandPublishing[commandPublishing] enabled

** xref:extensions:command-log:about.adoc[Command Log] extension
+
provides an implementation that simply logs actions for

** xref:extensions:command-replay:about.adoc[Command Replay] extension
+
provides an implementation to replicate commands from a primary to a secondary system.
+
This implementation also leverages xref:system:generated:index/applib/annotation/Action.adoc#commandDtoProcessor[commandDtoProcessor()] to process ``CommandDto``s before being replciated

* xref:system:generated:index/applib/services/publishing/spi/ExecutionSubscriber.adoc[ExecutionSubscriber] SPI
+
for actions where xref:system:generated:index/applib/annotation/Action.adoc#executionPublishing[executionPublishing] is enabled

== See also

* xref:system:generated:index/applib/services/eventbus/EventBusService.adoc[EventBusService]
+
which broadcast the action's domain event -- as specified by xref:system:generated:index/applib/annotation/Action.adoc#domainEvent[domainEvent()] --  for business rule checking (hide, disable, validate) and its invocation (pre-execute and post-execute).
