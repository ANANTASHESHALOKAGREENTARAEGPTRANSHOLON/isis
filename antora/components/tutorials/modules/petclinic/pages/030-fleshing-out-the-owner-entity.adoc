= Fleshing out the `Owner` entity

:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.


== Exercise 3.1: Rename PetOwner's name property

In the domain we are working on, `Owner` has a `firstName` and a `lastName` property, not a single `name` property.

In this exercise, we'll rename ``PetOwner``'s `name` property to be `lastName`, and change the fixture script that sets up data to something more realistic.



=== Solution

[source,bash]
----
git checkout tags/03-01-renames-PetOwner-name-property
mvn clean install
mvn -pl spring-boot:run
----

Remember you can use the menu:Prototyping[Fixture Scripts] menu to setup some example data.


=== Tasks

Checkout the solution above and review the git history to see the changes that have already been made.
These include:

* property `PetOwner#name` -> `PetOwner#lastName` renamed
* JPA mappings updated:
** the corresponding JPQL named queries
** the method names of `PetOwnerRepository`
+
This is a Spring Data repository, which uses a link:https://www.baeldung.com/spring-data-derived-queries[naming convention] to infer the queries

** uniqueness constraint for `PetOwner`

* the action method names of `PetOwners` domain service renamed
+
This also requires updating the `menubars.layout.xml`, which references these action names.

* updating the xref:refguide:applib:index/annotation/ActionLayout.adoc#associateWith[@ActionLayout] of the `updateName` and `delete` action methods in `PetOwner`
+
In the UI, the buttons for these actions are located close to the renamed "lastName" property

* renames `@Name` meta-annotation to `@LastName`.
+
Meta-annotations are a useful way of eliminating duplication where the same value type appears in multiple locations, for example as both an entity property and in action parameters.

Build and run the application to make sure it still runs fine.



== Exercise 3.2: Add PetOwner's firstName property

Now that `PetOwner` has a `lastName` property, let's also add a `firstName` property.
We'll also update our fixture script (which sets up ``PetOwner``s) so that it is more descriptive.


=== Solution

[source,bash]
----
git checkout tags/03-02-adds-PetOwner-firstName-property
mvn clean install
mvn -pl spring-boot:run
----

=== Tasks

* copy `@LastName` meta-annotation to create `@FirstName`:
+
[source,java]
----
@Property(maxLength = FirstName.MAX_LEN, optionality = Optionality.OPTIONAL)
@Parameter(maxLength = FirstName.MAX_LEN, optionality = Optionality.OPTIONAL)
@ParameterLayout(named = "First Name")
@Target({ ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
public @interface FirstName {

    int MAX_LEN = 40;
}
----
+
Note that this property/parameter is optional.
Its parameter name has also been updated.


* add a new (JPA nullable) property `firstName` to `PetOwner`:
+
[source,java]
----
@FirstName
@Column(length = FirstName.MAX_LEN, nullable = true)
@Getter @Setter @ToString.Include
@PropertyLayout(fieldSetId = "name", sequence = "2")
private String firstName;
----

* add a new factory method to accept a `firstName`, and refactor the existing one:
+
[source,java]
----
public static PetOwner withName(String name) {
    return withName(name, null);
}

public static PetOwner withName(String lastName, String firstName) {
    val simpleObject = new PetOwner();
    simpleObject.setLastName(lastName);
    simpleObject.setFirstName(firstName);
    return simpleObject;
}
----


* remove `@Title` annotation from `lastName` property, and add a `title()` method to derive from both properties:
+
[source,java]
----
public String title() {
    return getLastName() + (getFirstName() != null ? ", " + getFirstName() : "");
}
----


* Update the `PetOwner_persona` enum with more realistically last names (family names).
+
Learn more about fixture scripts xref:testing:fixtures:about.adoc[here].



== Exercise 3.3: Modify PetOwner's updateName action

Although we've added a `firstName` property, currently it can't be edited.
In this exercise we'll modify the `updateName` action to also allow the `firstName` to be changed.

=== Solution

[source,bash]
----
git checkout tags/03-03-modifies-PetOwner-updateName-action
mvn clean install
mvn -pl spring-boot:run
----

=== Tasks

* update `Owner#updateName` to also accept a new `firstName` parameter:
+
image::03-03/refactor-updateName.png[width=800px]
+
[source,java]
----
@Action(semantics = IDEMPOTENT, commandPublishing = Publishing.ENABLED, executionPublishing = Publishing.ENABLED)
@ActionLayout(associateWith = "lastName", promptStyle = PromptStyle.INLINE)
public PetOwner updateName(
        @LastName final String lastName,
        @FirstName String firstName) {
    setLastName(lastName);
    setFirstName(firstName);
    return this;
}
public String default0UpdateName() {
    return getLastName();
}
public String default1UpdateName() {
    return getFirstName();
}
----

* add in a "default" supporting method for the new parameter.
+
[source,java]
----
public String default1UpdateName() {
    return getFirstName();
}
----
+
The "default" supporting methods are called when the action prompt is rendered, providing the default for the "Nth" parameter of the corresponding action.




== Exercise 3.4: Modify the menu action to create PetOwners

If we want to create a new `PetOwner` and provide their `firstName`, at the moment it's a two stage process: create the `PetOwner` (using `PetOwners#create` action from the menu), then update their name (using the `updateName` action that we just looked at).

In this exercise we'll simplify that workflow by allowing the `firstName` to optionally be specified during the initial create.

=== Solution

[source,bash]
----
git checkout tags/03-04-modifies-PetOwners-create-action
mvn clean install
mvn -pl spring-boot:run
----

=== Tasks

* update `Orders#create` action, so that the end user can specify a `firstName` when creating a new `PetOwner`:
+
[source,java]
----
@Action(semantics = SemanticsOf.NON_IDEMPOTENT)
@ActionLayout(promptStyle = PromptStyle.DIALOG_SIDEBAR)
public PetOwner create(
        @LastName final String lastName,
        @FirstName final String firstName) {
    return repositoryService.persist(PetOwner.withName(lastName, firstName));
}
----


=== Optional exercise

It would be nice if the `PetOwner` were identified by both their `firstName` and their `lastName`; at the moment every `PetOwner` must have a unique `lastName`.
Or, even better would be to introduce some sort of "customerNumber" and use this as the unique identifier.

If you decide to do this optional exercise, create it on a git branch so that you can resume with the main flow of exercises later.



== Exercise 3.5: Initial Fixture Script

As we prototype with an in-memory database, it means that we need to setup the database each time we restart the application.
Using the menu:Prototyping[Fixture Scripts] menu to setup data saves some time, but it would nicer still if that script could be run automatically.
We can do that by specifying a configuration property.

We can also leverage link:https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.profiles[Spring Boot profiles] to keep this configuration separate.


=== Solution

[source,bash]
----
git checkout tags/03-05-initial-fixture-script
mvn clean install
mvn -pl spring-boot:run
----


=== Tasks

* create the following file in `src/main/resources` of the webapp (alongside the existing `application.yml` file):
+
[source,yaml]
.application-dev.yaml
----
isis:
  testing:
    fixtures:
      initial-script: petclinic.webapp.application.fixture.scenarios.PetClinicDemo
----

* modify the startup of your application to enable this profile, using this system prpoerty:
+
[source]
----
-Dspring.profiles.active=dev
----

When you run the application you should now find that there are 10 `PetOwner` objects already created.




== Exercise 3.6: Prompt styles

The framework provides many ways to customise the UI, either through the layout files or using the `@XxxLayout` annotations.
Default UI conventions can also be specified using the `application.yml` configuration file.

In this exercise we'll change the prompt style for both a service (menu) action, ie `PetOwners#create`, and an object action, ie `PetOwner#updateName`.


=== Solution

[source,bash]
----
git checkout tags/03-06-prompt-styles
mvn clean install
mvn -pl spring-boot:run
----


=== Tasks

* Service (menu) actions are always shown in a dialog, of which there are two styles: modal prompt, or sidebar.
If not specified explicitly, they will default to dialog modal.
+
Therefore remove the `@ActionLayout(promptStyle)` for `PetOwners#create` and confirm that the dialog is now shown as a modal prompt.

* Object actions can be shown either inline or in a dialog, but default to inline.
If forced to use a dialog, then they default to a sidebar prompt rather than a modal prompt.
+
Therefore remove the `@ActionLayout(promptStyle)` for `PetOwner#updateName` and confirm that prompt is still inline.

* Using a configuration property we can change the default for object actions to use a dialog rather than inline.
+
using the Spring boot profile trick from before:
+
[source,yaml]
.application-custom.yaml
----
isis:
  viewer:
    wicket:
      prompt-style: dialog
----
+
Remember to activate this new profile (`-Dspring.profiles.active=dev,custom`) and confirm that the `updateName` prompt now uses a sidebar dialog.

* We can overide the default dialog style for both service and object actions using further configuration properties.
+
Switch the defaults so that service actions prefer to use a sidebar dialog, while object actions would use a modal dialog:
+
[source,yaml]
.application-custom.yaml
----
isis:
  viewer:
    wicket:
      prompt-style: dialog
      dialog-mode: modal
      dialog-mode-for-menu: sidebar
----

* Optional: now use `@ActionLayout(promptStyle=...)` to override these defaults.
+
Be aware that "inline" makes no sense/is not supported for service actions.

* Finish off the exercises by setting up these defaults to retain the original behaviour:
+
[source,yaml]
.application-custom.yaml
----
isis:
  viewer:
    wicket:
      prompt-style: inline
      #dialog-mode: modal   # unused if prompt-style is inline
      dialog-mode-for-menu: sidebar
----





== Exercise 3.7: Derived name property

The ``PetOwner``'s `firstName` and `lastName` properties are updated using the `updateName` action, but when the action's button is invoked, it only "replaces" the `lastName` property:

image::Owner-updateName-prompt.png[width="400px",link="_images/Owner-updateName-prompt.png"]

In this exercise we'll improve the UI by introducing a derived `name` property and then hiding the `firstName` and `lastName`:

image::Owner-name.png[width="400px",link="_images/Owner-name.png"]

When `PetOwner#updateName` is invoked, the prompt we'll want see is:

image::Owner-name-updated.png[width="400px",link="_images/Owner-name-updated.png"]


=== Solution

[source,bash]
----
git checkout tags/03-07-derived-PetOwner-name
mvn clean install
mvn -pl spring-boot:run
----


=== Tasks


* Add `getName()` as the derived `name` property:
+
[source,java]
----
@Transient
@PropertyLayout(fieldSetId = "name", sequence = "1")
public String getName() {
    return getFirstName() + " " + getLastName();
}
----

* Hide the `lastName` and `firstName` properties, using `@Property(hidden=...)`.
We can also remove the `@PropertyLayout` annotation.
+
[source,java]
----
@LastName
@Column(length = LastName.MAX_LEN, nullable = false)
@Getter @Setter @ToString.Include
@Property(hidden = Where.EVERYWHERE)
private String lastName;

@FirstName
@Column(length = FirstName.MAX_LEN, nullable = true)
@Getter @Setter @ToString.Include
@Property(hidden = Where.EVERYWHERE)
private String firstName;
----


* Update the `PetOwner#updateName` to associate with the new `name` property:
+
[source,xml]
----
@ActionLayout(associateWith = "name",)
public PetOwner updateName( ... ) {}
----


Run the application and check that it behaves as you expect.

However, if you now try to build the app (`mvn clean install`) then you'll hit test errors, because we have changed the visibility of the `lastName` and `firstName` properties.

We will be looking at tests later on, so if you want to just comment out the failing tests, then do that.
Alternatively, here are the changes that need to be made:

* update the `PetOwner_IntegTest#name` nested static test class:
+
[source,java]
----
@Nested
public static class name extends PetOwner_IntegTest {

    @Test
    public void accessible() {
        // when
        final String name = wrap(petOwner).getName();   // <.>

        // then
        assertThat(name).isEqualTo(petOwner.getLastName());
    }

    // <.>
}
----
<.> change this line from `getLastName()` to `getName()`
<.> delete the 'editable' test

* add a new `PetOwner_IntegTest#lastName` nested static test class to check that the `lastName` property can no longer be viewed:
+
[source,java]
----
@Nested
public static class lastName extends PetOwner_IntegTest {

    @Test
    public void not_accessible() {
        // expect
        assertThrows(HiddenException.class, ()->{

            // when
            wrap(petOwner).getLastName();
        });
    }
}
----
+
This asserts that the `lastName` property cannot be viewed.

* add a new `PetOwner_IntegTest#firstName` nested static test class to check that the `firstName` property can no longer be viewed.
+
[source,java]
----
@Nested
public static class firstName extends PetOwner_IntegTest {

    @Test
    public void not_accessible() {
        // expect
        assertThrows(HiddenException.class, ()->{

            // when
            wrap(petOwner).getFirstName();
        });
    }
}
----

* update the `PetOwner_IntegTest#updateName` nested static test class, specifically the assertion:
+
[source,java]
----
@Nested
public static class updateName extends PetOwner_IntegTest {


    @Test
    public void can_be_updated_directly() {

        // when
        wrap(petOwner).updateName("McAdam", "Adam");                // <.>
        transactionService.flushTransaction();

        // then
        assertThat(petOwner.getLastName()).isEqualTo("McAdam");     // <.>
        assertThat(petOwner.getFirstName()).isEqualTo("Adam");      // <2>
    }
    //...
}
----
<.> provide both `lastName` and `firstName` parameters
<.> assert on both properties.
Note that the `petOwner` object cannot be "wrapped".

In case you are wondering, the wrap method is a call to xref:refguide:applib:index/services/wrapper/WrapperFactory.adoc[WrapperFactory], which provides a proxy to the object.
This proxy emulates the UI, in this case enforcing the "hidden" rule by throwing an exception if it would not be visible.
For this test, we _want_ to peek under the covers to check the direct state of the entity, therefore we don't wrap the object.





== Add other properties for `Owner`

UP to here

Let's add the two remaining properties for `Owner`.

[plantuml]
----
hide empty members
hide methods

class Owner {
    +id
    ..
    #lastName
    #firstName
    ..
    -phoneNumber
    -emailAddress
}
----

=== Solution

[source,bash]
----
git checkout tags/110-add-other-properties-for-Owner
mvn clean package jetty:run
----

=== Exercise

* Add `phoneNumber` as an editable property and use a regex to limit the allowed characters:
+
[source,java]
----
@javax.jdo.annotations.Column(allowsNull = "true", length = 15)
@Property(
        editing = Editing.ENABLED,
        regexPattern = "[+]?[0-9 ]+",
        regexPatternReplacement =
            "Specify only numbers and spaces, optionally prefixed with '+'.  " +
            "For example, '+353 1 555 1234', or '07123 456789'"
)
@Getter @Setter
private String phoneNumber;
----
+
Until we update `Owner.layout.xml`, then the new property will be added to the section specified `unreferencedProperties="true"`, in other words a field set called "Other".

* Add `emailAddress` as an editable property and use a supporting `validate` method to verify the format:
+
[source,java]
----
@javax.jdo.annotations.Column(allowsNull = "true", length = 50)
@Property(editing = Editing.ENABLED)
@Getter @Setter
private String emailAddress;
public String validateEmailAddress(String emailAddress) {
    return emailAddress.contains("@") ? null : "Email address must contain a '@'";
}
----
+
Obviously in this previous case we could also have used a declarative approach, but using a "validate" method here shows that arbitrary logic can be used.
For example, we could delegate to an injected domain service to actually validate the email.

* update `Owner.layout.xml`.
+
While we are at it, we could move the `notes` property to its own tab:
+
[source,xml]
----
<bs3:tab name="Contact Details">
    <bs3:row>
        <bs3:col span="12">
            <c:fieldSet name="Contact Details">
                <c:property id="emailAddress"/>
                <c:property id="phoneNumber"/>
            </c:fieldSet>
        </bs3:col>
    </bs3:row>
</bs3:tab>
<bs3:tab name="Notes">
    <bs3:row>
        <bs3:col span="12">
            <c:fieldSet name="Notes">
                <c:property id="notes" namedEscaped="true" multiLine="10" hidden="ALL_TABLES"/>
            </c:fieldSet>
        </bs3:col>
    </bs3:row>
</bs3:tab>
----
+
resulting in:

image::Owner-with-contact-details.png[width="600px",link="_images/Owner-with-contact-details.png"]


== Using specifications to encapsulate business rules

When we create a new `Owner` we specify only the first and last name.
If the owner has a phone number, then the user has to edit that property separately.

Suppose we wanted to allow the user to optionally enter the phone number when the `Owner` is first created?
That would require extending the `Owners#create(...)` action to also accept an optional "phoneNumber" parameter.

However, the regex validation rule that we've specified on `Owner#phoneNmber` will need duplicating for the `phoneNumber` parameter; the framework doesn't "know" that the value is to be used to populate that particular property.
But duplicating validation violates the single responsibility principle.

Instead, we can move the validation logic into a "specification", and associate both the property and the parameter with that specification.

=== Solution

[source,bash]
----
git checkout tags/120-using-specifications-to-encapsulate-business-rules
mvn clean package jetty:run
----

=== Exercise

* factor out a `PhoneNumberSpec`:
+
[source,java]
----
public static class PhoneNumberSpec extends AbstractSpecification<String> {
    @Override
    public String satisfiesSafely(final String phoneNumber) {
        Matcher matcher = Pattern.compile("[+]?[0-9 ]+").matcher(phoneNumber);
        return matcher.matches() ? null :
                "Specify only numbers and spaces, optionally prefixed with '+'.  " +
                "For example, '+353 1 555 1234', or '07123 456789'";
    }
}
----
+
[TIP]
====
In this case it isn't required, but we could if we wanted inject domain services into this specification class.
====

* refactor the `phoneNumber` property to use this spec:
+
[source,java]
----
@javax.jdo.annotations.Column(allowsNull = "true", length = 15)
@Property(editing = Editing.ENABLED,
        mustSatisfy = PhoneNumberSpec.class
)
@Getter @Setter
private String phoneNumber;
----

* extend the `Orders#create` action to also extend a `phoneNumber` parameter, and use the `PhoneNumberSpec` to implement the same business rule:
+
image::Owners-create-with-phoneNumber.png[width="400px",link="_images/Owners-create-with-phoneNumber.png"]
+
using this code:
+
[source,java]
----
@Action(semantics = SemanticsOf.NON_IDEMPOTENT)
@MemberOrder(sequence = "1")
public Owner create(
        @Parameter(maxLength = 40)
        final String lastName,
        @Parameter(maxLength = 40)
        final String firstName,
        @Parameter(
                mustSatisfy = Owner.PhoneNumberSpec.class,
                maxLength = 15,
                optionality = Optionality.OPTIONAL
        )
        final String phoneNumber) {
    Owner owner = new Owner(lastName, firstName);
    owner.setPhoneNumber(phoneNumber);
    return repositoryService.persist(owner);
}
----


[NOTE]
====
The above refactoring isn't perfect: there is still some repetition of the length of the property/parameter, for example.

The next version of the framework will support custom meta-annotations which will address this.
Then, you'll be able to write:

[source,java]
----
@javax.jdo.annotations.Column(allowsNull = "true", length = 15)
@Property(
    mustSatisfy = Owner.PhoneNumberSpec.class
)
@Parameter(
    mustSatisfy = Owner.PhoneNumberSpec.class,
    maxLength = 15,
    optionality = Optionality.OPTIONAL
)
public @interace @PhoneNumber {}
----

and then:

[source,java]
----
@PhoneNumber
@Getter @Setter
private String phoneNumber;
----

and

[source,java]
----
public Owner create(
        final String lastName,
        final String firstName,
        @PhoneNumber
        final String phoneNumber) { ... }
----

====


