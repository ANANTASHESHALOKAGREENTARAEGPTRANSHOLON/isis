Usually a domain event is emitted by the framework to emit whenever the user interacts with an action.
Domain service subscribers can influence this interaction, either by:

* hiding the action
* disabling the action
* validating arguments of the action invocation
* modifying the proposed value
* performing actions after the property has been modified
* performing arbitrary operations before the action has been invoked (including modifying the argument values to be used)
* performing arbitrary operations after the action has been modified (including changing the apparent return value of the action)

CAUTION: TODO - to be updated.


The `domainEvent` semantic specifies the class to be emitted; this must be a subclass of the abstract `org.apache.isis.applib.events.domain.ActionDomainEvent` class.

If no `domainEvent` is specified at the property level, then the domain event class can be specified at the class level using `@DomainObject#propertyDomainEvent`.
And if not specified at the class level, then an instance of `org.apache.isis.applib.events.domain.PropertyDomainEvent.Default` is emitted as the fallback.

[TIP]
====
The fallback domain event can be suppressed if required using the `isis.applib.annotation.property.domain-event.post-for-default` configuration property.
====

In the demo, the `ActionDomainEventVm` class defines an editable property, "text", annotated with `domainEvent`:

[source,java]
----
include::ActionDomainEventVm.java[tags=class]
----
<.> the event class to emit; genericised by the target type and the property type
<.> indiates that the framework should emit this type

PropertyDomainEventVm_controlTextEditing mixin:

The `ControlService` is the subscriber:

[source,java]
----
include::subscribers/ControlService.java[tags=class]
----
<.> holds which "strategy" should be used to modify the interactions with the text field
<.> subscribes using the Spring event bus

The strategies themselves -- which demonstrate the options available -- are implemented as an enum.
The `DO_NOTHING` enum, unsurprisingly, does nothing:

[source,java]
----
include::subscribers/ControlStrategy.java[tags=class]
----

There are five further options:

* hide
+
[source,java,indent=0]
----
include::subscribers/ControlStrategy.java[tags=hide]
----

* disable
+
[source,java,indent=0]
----
include::subscribers/ControlStrategy.java[tags=disable]
----

* validate
+
[source,java,indent=0]
----
include::subscribers/ControlStrategy.java[tags=validate]
----

* executing
+
[source,java,indent=0]
----
include::subscribers/ControlStrategy.java[tags=executing]
----

* executed
+
[source,java,indent=0]
----
include::subscribers/ControlStrategy.java[tags=executed]
----

Two mixins then work together:

* the `controlText` mixin property just surfaces the selected strategy as a read-only value:
+
[source,java]
----
include::subscribers/ActionDomainEventVm_controlText.java[tags=class]
----

* while the `controlTextEditing` mixin action allows the strategy to be changed:
+
[source,java]
----
include::subscribers/ActionDomainEventVm_controlTextEditing.java[tags=class]
----

