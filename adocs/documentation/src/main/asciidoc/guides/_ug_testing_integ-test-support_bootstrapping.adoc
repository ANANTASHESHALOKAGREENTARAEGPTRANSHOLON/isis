[[_ug_testing_integ-test-support_bootstrapping]]
= Bootstrapping
:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:_basedir: ../
:_imagesdir: images/


Integration tests instantiate an Apache Isis "runtime" (as a singleton) within a JUnit test.  Because (depending on the size of your app) it takes a little time to bootstrap Apache Isis, the framework caches the runtime on a thread-local from one test to the next.

Nevertheless, we do need to bootstrap the runtime for the very first test.

Since the integration tests don't depend on the `webapp` module, it's necessary to repeat all the (relevant) all the configuration in `isis.properties` and related files.  That said, in practice the relevant information isn't all that much.

[NOTE]
====
We hope to simplify the way this works in future versions of Apache Isis.
====

The example code in this section is taken from the app generated by the xref:ug.adoc#_ug_getting-started_simpleapp-archetype[SimpleApp archetype].




== Builder

The bootstrapping itself is mostly performed by a subclass of the `IsisSystemForTest.Builder` class:

[source,java]
----
private static class SimpleAppSystemBuilder extends IsisSystemForTest.Builder {      // <1>

    public SimpleAppSystemBuilder() {
        withLoggingAt(org.apache.log4j.Level.INFO);
        with(testConfiguration());
        with(new DataNucleusPersistenceMechanismInstaller());                        // <2>

        withServicesIn( "domainapp" );                                               // <3>
    }

    private static IsisConfiguration testConfiguration() {
        final IsisConfigurationForJdoIntegTests testConfiguration =
            new IsisConfigurationForJdoIntegTests();                                 // <4>

        testConfiguration.addRegisterEntitiesPackagePrefix("domainapp.dom.modules"); // <5>
        return testConfiguration;
    }
}
----
<1> subclass the framework-provided `IsisSystemForTest.Builder`.
<2> equivalent to `isis.persistor=datanucleus` in `isis.properties`
<3> specify the `isis.services` key in `isis.properties` (where "domainapp" is the base package for all classes within the app)
<4> `IsisConfigurationForJdoIntegTests` has pre-canned configuration for using an in-memory HSQLDB and other standard settings; more on this below.
<5> equivalent to `isis.persistor.datanucleus.RegisterEntities.packagePrefix` key (typically in `persistor_datanucleus.properties`




=== IsisConfigurationForJdoIntegTests

Integration tests are configured programmatically, with a default set of properties to bootstrap the JDO/DataNucleus objectstore using an HSQLDB in-memory database.

To remove a little bit of boilerplate, the `IsisConfigurationForJdoIntegTests` class (in the `org.apache.isis.objectstore.jdo.datanucleus` package) can be used to bootstrap the application.  If necessary, this class can be subclassed to override these defaults.


.Default Configuration Properties for Integration Tests
[cols="2a,1,3a", options="header"]
|===
|Property
|Value
|Description

|`isis.persistor.datanucleus.impl.` +
`javax.jdo.option.ConnectionURL`
|jdbc:hsqldb:mem:test
|JDBC URL

|`isis.persistor.datanucleus.impl.` +
`javax.jdo.option.ConnectionDriverName`
|org.hsqldb.jdbcDriver
|JDBC Driver

|`isis.persistor.datanucleus.impl.` +
`javax.jdo.option.ConnectionUserName`
|sa
|Username

|`isis.persistor.datanucleus.impl.` +
`javax.jdo.option.ConnectionPassword`
|<empty string>
|Password

|`isis.persistor.datanucleus.impl.` +
`datanucleus.schema.autoCreateAll`
|true
|Recreate DB for each test run (an in-memory database)

|`isis.persistor.datanucleus.impl.` +
`datanucleus.schema.validateAll`
|false
|Disable validations (minimize bootstrap time)

|`isis.persistor.datanucleus.impl.` +
`datanucleus.persistenceByReachabilityAtCommit`
|false
|As per WEB-INF/persistor_datanucleus.properties

|`isis.persistor.datanucleus.impl.` +
`datanucleus.identifier.case`
|MixedCase
|As per WEB-INF/persistor_datanucleus.properties

|`isis.persistor.datanucleus.impl.` +
`datanucleus.cache.level2.type`
|none
|As per WEB-INF/persistor_datanucleus.properties

|`isis.persistor.datanucleus.impl.` +
`datanucleus.cache.level2.mode`
|ENABLE_SELECTIVE
|As per WEB-INF/persistor_datanucleus.properties

|`isis.persistor.datanucleus.` +
`install-fixtures`
|true
|Automatically install any fixtures that might have been registered

|`isis.persistor.` +
`enforceSafeSemantics`
|false
|

|`isis.deploymentType`
|server_prototype
|
|===





== System Initializer

The builder is defined and used within a class we call the system initializer that is responsible for instantiating the Apache Isis runtime, and binding it to a thread-local.  This is performed within a static `initIsft()` method.

Here's the code:

[source,java]
----
public class SimpleAppSystemInitializer {
    public static void initIsft() {
        IsisSystemForTest isft = IsisSystemForTest.getElseNull();
        if(isft == null) {
            isft = new SimpleAppSystemBuilder()    // <1>
                            .build()
                            .setUpSystem();
            IsisSystemForTest.set(isft);           // <2>
        }
    }
    private static class SimpleAppSystemBuilder
        extends IsisSystemForTest.Builder { ... }

}
----
<1> instantiates and initializes the Apache Isis runtime (the `IsisSystemForTest` class)
<2> binds the runtime to a thread-local.




== Abstract Class

We recommend defining a base class for all your other classes to integration classes to inherit from.  The main responsibility of this class is tocall the system initializer, described earlier.  We only need the initialization to be performed once, so this call is performed in a `@BeforeClass` hook.

The code below shows the general form:

[source,java]
----
public abstract class SimpleAppIntegTest {
    @BeforeClass
    public static void initClass() {
        org.apache.log4j.PropertyConfigurator.configure("logging.properties");   // <1>
        SimpleAppSystemInitializer.initIsft();                                   // <2>
        new ScenarioExecutionForIntegration();                                   // <3>
    }
}
----
<1> ensure that logging messages don't get swallowed
<2> initialize the Apache Isis runtime
<3> primarily exists to support the writing of xref:ug.adoc#_ug_testing_bdd-spec-support[BDD specifications], but also enables finer-grained management of sessions/transactions (discussed below).



=== `IntegrationTestAbstract`

In fact, we recommend that your base class inherit from Apache Isis' `IntegrationTestAbstract` class:

[source,java]
----
public abstract class SimpleAppIntegTest extends IntegrationTestAbstract {
    ...
}
----

Although not mandatory, this provides a number of helper/convenience methods and JUnit rules:

[source,java]
----
    @Rule
    public IsisTransactionRule isisTransactionRule =                         // <1>
        new IsisTransactionRule();
    @Rule
    public JUnitRuleMockery2 context =                                       // <2>
        JUnitRuleMockery2.createFor(Mode.INTERFACES_AND_CLASSES);
    @Rule
    public ExpectedException expectedExceptions =                            // <3>
        ExpectedException.none();
    @Rule
    public ExceptionRecognizerTranslate exceptionRecognizerTranslations =    // <4>
        ExceptionRecognizerTranslate.create();
----
<1> ensures an Apache Isis session/transaction running for each test
<2> sets up a JMock context (using Apache Isis' extension to JMock as described in xref:ug.adoc#_ug_testing_unit-test-support_jmock-extensions[JMock Extensions].
<3> standard JUnit rule for writing tests that throw exceptions
<4> to capture messages that require translation, as described in xref:ug.adoc#_ug_more-advanced_i18n[i18 support].

All of these rules could be inlined in your own base class; as we say, they are a convenience.

In addition, `IntegrationTestAbstract` provides a number of helper/convenience methods.  Most important amongst these are `nextSession()` and `nextTransaction()` that to allow tests to simulate multiple separate user interactions (each of which would normally occur in a separate transaction).

It also provides `wrap(...)` and `unwrap(...)` which delegate to the `WrapperFactory`.  We talk about these methods in the next section

