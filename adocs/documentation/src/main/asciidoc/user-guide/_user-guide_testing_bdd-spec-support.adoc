= BDD Spec Support
:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:_basedir: ../
:_imagesdir: images/

IMPORTANT: TODO



== Concepts

The `isis-core-specsupport` and `isis-core-integtestsupport` modules provide the ability to bootstrap Isis and run either BDD specifications
or regular integration tests.

*

In the case of BDD specs, these are run using https://github.com/cucumber/cucumber-jvm[Cucumber-JVM], the Java port of the original Ruby http://cukes.info[Cucumber] tool.

Specifications are written in the https://github.com/cucumber/cucumber/wiki/Gherkin[Gherkin] DSL, following the https://github.com/cucumber/cucumber/wiki/Given-When-Then["given/when/then"] format. Cucumber-JVM itself is a JUnit runner, and searches for https://github.com/cucumber/cucumber/wiki/Feature-Introduction[feature files] on the classpath. These in turn are matched to http://cukes.info/step-definitions.html[step definition]s through regular expressions. It is the step definitions (the "glue") that exercise the system.

*

In the case of integration tests, these are run using JUnit.

To untangle the above a little: in terms of lines of code to be written, the code that goes in step definitions is broadly the same as the code that goes in an integration test method. The benefit of the former is that the given/then/when scenarios feature file describe the context of the interaction, and the step definitions are reusable across scenarios.

There are some key framework classes that make up the spec/integtest support; these are discussed below.

=== IsisSystemForTest

To support both BDD specs and integration tests, Isis provides the `IsisSystemForTest` class. This allows a complete running instance of Isis to be bootstrapped (usually with the JDO objectstore), and then held on a `ThreadLocal` from one test to another.

Typically bootstrapping code is used to lazily instantiate the `IsisSystemForTest` once and once only. The mechanism for doing this is line-for-line identical in both BDD step defs and integration tests.

=== ScenarioExecution

Isis also provides a `ScenarioExecution` class. The purpose of this class is to provide a context under which the specification or an integration test is executing.

For both BDD specs and integration tests, the `ScenarioExecution` also provides access to the configured domain services (accessible through the `service(...)` method) and the `DomainObjectContainer` (through the `container()` method).

In addition, UI behaviour can be integration tested by "wrapping" each domain object in a proxy. This proxy ensures that the "see it/use it/do it" rules (ie to hide, disable, or validate) are enforced. The wrapping is performed using the `WrapperFactory`, part of the link:../reference/services/wrapper-factory.html[isis-core-wrapper] module. The `ScenarioExecution`'s `wrap()` and `unwrap()` helper methods provide access to this capability.

The `ScenarioExecution` also provides the `install()` method, allowing fixtures to be installed in the normal way. If using the JDO Object store, then these fixtures the `IsisJdoSupport` service can be used to run arbitrary SQL against the underlying database (eg to truncate/delete existing tables as need be).

Of relevance only to BDD specs, the `ScenarioExecution`'s `getVar()` and `putVar()` methods also allow variables to be passed from one step definition to the next. (Broadly speaking, this is the same as the "World" object in Ruby-flavoured Cucumber).

Like the `IsisSystemForTest` class, the `ScenarioExecution` class also binds an instance of itself onto a `ThreadLocal`. It can then be accessed in both BDD step defs and in integration tests using `ScenarioExecution.current()` static method.

=== CukeGlueAbstract and IntegrationTestAbstract

The `CukeGlueAbstract` acts as a convenience superclass for writing BDD step definitions. Similarly, the `IntegrationTestAbstract` acts as a convenience subclass for writing integration tests. These two classes are very similar in that they both delegate to an underlying `ScenarioExecution`.

=== Separate Glue from Specs

The "glue" (step definitions) are intended to be reused across features. We therefore recommend that they reside in a separate package, and are organized by the entity type upon which they act.

For example, given a feature that involves `Customer` and `Order`, have the step definitions pertaining to `Customer` reside in `CustomerGlue`, and the step definitions pertaining to `Order` reside in `OrderGlue`.

The Cucumber-JVM spec runner allows you to indicate which package(s) should be recursively searched to find any glue.

=== Integration- vs Unit- Scope

Although BDD specs are most commonly used for end-to-end tests (ie at the same scope as an integration test), the two concerns (expressability of a test to a business person vs granularity of the test) should not be conflated. There are a couple of http://silkandspinach.net/2013/01/18/a-testing-strategy/[good] blog http://claysnow.co.uk/the-testing-iceberg/[posts] discussing http://claysnow.co.uk/living-documentation-can-be-readable-and-fast/[this]. The basic idea is to avoid the overhead of a heavy-duty integration test if possible.

Isis takes inspiration from these to optionally allow BDD specs to be run at a unit scope. The scope is indicated by annotating the scenario with the `@unit` or `@integration` tags.

When running under unit-level scope, the Isis system is _not_ instantiated. Instead, `ScenarioExecution` class returns JMock mocks (except for the `WrapperFactory`, if configured).

Writing a BDD spec that supports both modes of operation therefore takes more effort, but the benefit is a (much) faster executing test suite. Writing to support both modes means that the developer/tester can easily check the scenario at both scopes just by altering the tag.

To support unit-testing, Isis provides the `InMemoryDB` class; a glorified hashmap of "persisted" objects. Use of this utility class is optional.

== Usage

The following examples are taken from the https://github.com/apache/isis/tree/master/example/application/todoapp[todoapp]; in particular from that project's https://github.com/apache/isis/tree/master/example/application/todoapp/integtests/src/test/java[integration test] module.

=== Root pom

In the root https://github.com/apache/isis/blob/master/example/application/todoapp/pom.xml[`pom.xml`], we recommend that you update the `maven-surefire-plugin` patterns, so that BDD specs are recognised alongside unit and integration tests:

[source]
----
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.10</version>
    <configuration>
        <includes>
            <include>**/*Test.java</include>
            <include>**/*Test_*.java</include>
            <include>**/*Spec*.java</include>
        </includes>
        <excludes>
            <exclude>**/Test*.java</exclude>
            <exclude>**/*ForTesting.java</exclude>
            <exclude>**/*Abstract*.java</exclude>
        </excludes>
        <useFile>true</useFile>
        <printSummary>true</printSummary>
        <outputDirectory>${project.build.directory}/surefire-reports</outputDirectory>
    </configuration>
</plugin>
----

=== Integration testing module

Assuming you have a module for your integration tests, add in the dependencies:

[source]
----
<dependency>
    <groupId>org.apache.isis.core</groupId>
    <artifactId>isis-core-specsupport</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.isis.core</groupId>
    <artifactId>isis-core-integtestsupport</artifactId>
</dependency>
----

There is no need to explicitly add in a dependency on `isis-core-wrapper`; this is done automatically.

=== Writing an Integration test

Integration tests should subclass from `IntegrationTestAbstract`. For example, here's a the https://github.com/apache/isis/blob/master/example/application/todoapp/integtests/src/test/java/integration/tests/actions/ToDoItemTest_completed.java[`ToDoItemTest_completed`] test which exercises of the `ToDoItem`'s `completed()` action:

[source]
----
public class ToDoItemTest_completed  {

    @BeforeClass
    public static void initClass() {
        PropertyConfigurator.configure("logging.properties");
        ToDoSystemInitializer.initIsft();

        // instantiating will install onto ThreadLocal
        new ScenarioExecutionForIntegration();
    }

    private ToDoItem toDoItem;

    @Before
    public void setUp() throws Exception {
        scenarioExecution().install(new ToDoItemsFixture());

        final List<ToDoItem> all = wrap(service(ToDoItems.class)).notYetComplete();
        toDoItem = wrap(all.get(0));
    }

    @Test
    public void happyCase() throws Exception {
        assertThat(toDoItem.isComplete(), is(false));
        toDoItem.completed();
        assertThat(toDoItem.isComplete(), is(true));
    }

    @Test
    public void cannotCompleteIfAlreadyCompleted() throws Exception {
        unwrap(toDoItem).setComplete(true);
        expectedExceptions.expectMessage("Already completed");
        toDoItem.completed();
    }

    @Test
    public void cannotSetPropertyDirectly() throws Exception {
        expectedExceptions.expectMessage("Always disabled");
        toDoItem.setComplete(true);
    }
}
----

The https://github.com/apache/isis/blob/master/example/application/todoapp/fixture/src/main/java/fixture/todo/ToDoItemsFixture.java[ToDoItemsFixture] referenced above tears down data as well as installs new data. In this example it runs at the class level (`@BeforeClass`), but it can also run at the instance level (`@Before`).

Note also that when the `ToDoItem` is wrapped, it is not possible to call `setComplete()` directly on the object; but when it is unwrapped then this call can be made as per normal.

The https://github.com/apache/isis/blob/master/example/application/todoapp/integtests/src/test/java/integration/ToDoSystemInitializer.java[ToDoSystemInitializer] class referenced above is responsible for setting up the `IsisSystemForTest`. You can think of it as being broadly equivalent to the information that is in the regular `isis.properties` file:

[source]
----
public class ToDoSystemInitializer {

    public static IsisSystemForTest initIsft() {
        IsisSystemForTest isft = IsisSystemForTest.getElseNull();
        if(isft == null) {
            isft = new ToDoSystemBuilder().build().setUpSystem();
            IsisSystemForTest.set(isft);
        }
        return isft;
    }

    private static class ToDoSystemBuilder extends IsisSystemForTest.Builder {
        public ToDoSystemBuilder() {
            withLoggingAt(Level.INFO);
            with(testConfiguration());
            with(new DataNucleusPersistenceMechanismInstaller());
            withServices(
                    new ToDoItemsJdo(),
                    new WrapperFactoryDefault(),
                    new RegisterEntities(),
                    new IsisJdoSupportImpl()
                    );
        }

        private IsisConfiguration testConfiguration() {
            // ... elided ...
        }
    }
}
----

=== Writing a BDD specification

BDD specifications contain a few more parts:

*

a `XxxSpec.feature` file, describing the feature and the scenarios (given/when/then)s that constitute its acceptance criteria

*

a `RunSpecs.java` class file to run the specification (all boilerplate). This will run all `.feature` files in the same package or subpackages.

*

one or several `XxxGlue` constituting the step definitions to be matched against. These are normally placed in a separate package(s) to the specifications; the `glue` attribute of the Cucumber-JVM JUnit runner indicates which package(s) to search in.

*

a system initializer class. This can be reused with any integration tests (eg the `ToDoSystemInitializer` class, shown above).

You may find it more convenient to place the `.feature` files in `src/test/java`, rather than `src/test/resources`. If you wish to do this, then your integration test module's `pom.xml` must contain:

[source]
----
<build>
    <testResources>
        <testResource>
            <filtering>false</filtering>
            <directory>src/test/resources</directory>
        </testResource>
        <testResource>
            <filtering>false</filtering>
            <directory>src/test/java</directory>
            <includes>
                <include>**</include>
            </includes>
            <excludes>
                <exclude>**/*.java</exclude>
            </excludes>
        </testResource>
    </testResources>
</build>
----

Let's now look at the a specification for the `ToDoItem&#39;`s "completed" feature. Firstly, the https://github.com/apache/isis/blob/master/example/application/todoapp/integtests/src/test/java/integration/specs/todoitem/ToDoItemSpec_findAndComplete.feature[`ToDoItemSpec_findAndComplete.feature`]:

[source]
----
@ToDoItemsFixture
Feature: Find And Complete ToDo Items

    @integration
    Scenario: Todo items once completed are no longer listed
      Given there are a number of incomplete ToDo items
      When  I choose the first of the incomplete items
      And   mark the item as complete
      Then  the item is no longer listed as incomplete
----

The `@ToDoItemsFixture` is a custom tag we've specified to indicate the prerequisite fixtures to be loaded; more on this in a moment. The `@integration` tag, meanwhile, says that this feature should be run with integration-level scope. (If we wanted to run at unit-level scope, the tag would be `@unit`).

The https://github.com/apache/isis/blob/master/example/application/todoapp/integtests/src/test/java/integration/specs/todoitem/RunSpecs.java[`RunSpecs`] class to run this feature (and any other features in this package or subpackages) is just boilerplate:

[source]
----
@RunWith(Cucumber.class)
@Cucumber.Options(
        format = {
                "html:target/cucumber-html-report",
                "json:target/cucumber.json"
        },
        glue={"classpath:com.mycompany.integration.glue"},
        strict = true,
        tags = { "~@backlog", "~@ignore" })
public class RunSpecs {
    // intentionally empty
}
----

The JSON formatter allows integration with enhanced reports, for example as provided by http://www.masterthought.net/section/cucumber-reporting[Masterthought.net] (screenshots at end of page). (Commented out) configuration for this is provided in the link:../intro/getting-started/simpleapp-archetype.html[simpleapp] `integtests` module's https://github.com/apache/isis/blob/07fe61ef3fb029ae36427f60da2afeeb931e4f88/example/application/simpleapp/integtests/pom.xml#L52[pom.xml].

The bootstrapping of Isis can be moved into a https://github.com/apache/isis/blob/07fe61ef3fb029ae36427f60da2afeeb931e4f88/example/application/simpleapp/integtests/src/test/java/domainapp/integtests/specglue/BootstrappingGlue.java#L26[`BootstrappingGlue`] step definition:

[source]
----
public class BootstrappingGlue extends CukeGlueAbstract {

    @Before(value={"@integration"}, order=100)
    public void beforeScenarioIntegrationScope() {
        PropertyConfigurator.configure("logging.properties");
        SimpleAppSystemInitializer.initIsft();

        before(ScenarioExecutionScope.INTEGRATION);
    }

    @After
    public void afterScenario(cucumber.api.Scenario sc) {
        assertMocksSatisfied();
        after(sc);
    }

    // bootstrapping of @unit scope omitted
}
----

The fixture to run also lives in its own step definition, https://github.com/apache/isis/blob/07fe61ef3fb029ae36427f60da2afeeb931e4f88/example/application/simpleapp/integtests/src/test/java/domainapp/integtests/specglue/CatalogOfFixturesGlue.java#L24[`CatalogOfFixturesGlue`]:

[source]
----
public class CatalogOfFixturesGlue extends CukeGlueAbstract {

    @Before(value={"@integration", "@SimpleObjectsFixture"}, order=20000)
    public void integrationFixtures() throws Throwable {
        scenarioExecution().install(new RecreateSimpleObjects());
    }

}
----

Note that this is annotated with a tag (`@SimpleObjectsFixture`) so that the correct fixture runs. (We might have a whole variety of these).

The step definitions pertaining to `SimpleObject` domain entity then reside in the https://github.com/apache/isis/blob/07fe61ef3fb029ae36427f60da2afeeb931e4f88/example/application/simpleapp/integtests/src/test/java/domainapp/integtests/specglue/modules/simple/SimpleObjectGlue.java#L31[`SimpleObjectGlue`] class. This is where the heavy lifting gets done:

[source]
----
public class SimpleObjectGlue extends CukeGlueAbstract {

    @Given("^there are.* (\\d+) simple objects$")
    public void there_are_N_simple_objects(int n) throws Throwable {
        try {
            final List<SimpleObject> findAll = service(SimpleObjects.class).listAll();
            assertThat(findAll.size(), is(n));
            putVar("list", "all", findAll);

        } finally {
            assertMocksSatisfied();
        }
    }

    @When("^I create a new simple object$")
    public void I_create_a_new_simple_object() throws Throwable {
        service(SimpleObjects.class).create(UUID.randomUUID().toString());
    }

}
----

== BDD Tooling

To help write feature files and generate step definitions, we recommend https://github.com/rlogiacco/Natural[Roberto Lo Giacco's Eclipse plugin]. For more information, see Dan's short http://danhaywood.com/2013/07/05/cucumber-editors-in-eclipse/[blog post]. It works very well. Of interest: this is implemented using http://www.eclipse.org/Xtext/[XText].