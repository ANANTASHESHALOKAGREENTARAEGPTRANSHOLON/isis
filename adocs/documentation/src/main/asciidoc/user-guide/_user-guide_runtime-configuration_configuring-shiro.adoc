= Configuring Shiro
:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:_basedir: ../
:_imagesdir: images/


Apache Isis' security mechanism is configurable, specifying an `Authenticator` and an `Authorizor` (non-public) APIs.  The Shiro security mechanism is an integration wih Apache Shiro that implements both interfaces.

[TIP]
====
The <<_simpleapp_archetype, SimpleApp archetype>> is pre-configured to use Apache Shiro, so much of what follows is set up already.
====

== Specifying Shiro as the security mechanism

To tell Apache Isis to use Shiro, update the `WEB-INF/isis.properties` file:

[source,ini]
----
isis.authentication=shiro
isis.authorization=shiro
----

This installs the appropriate implementation (the `ShiroAuthenticatorOrAuthorizor` class) that use Shiro's APIs to perform authentication and authorization.




== Bootstrapping Shiro

The Shiro environment (in essence, thread-locals holding the security credentials) needs to be bootstrapped using the following settings in the `WEB-INF/web.xml` file:

[source,xml]
----
<listener>
    <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
</listener>

<filter>
    <filter-name>ShiroFilter</filter-name>
    <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>ShiroFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
----

Based on this Shiro will then read `WEB-INF/shiro.ini` file to configure its Realm definitions for authentication and authorization.




== `WEB-INF/shiro.ini`

The `shiro.ini` file (at least as configured in the <<_simpleapp_archetype, SimpleApp archetype>>) is configured to use the built-in `$iniRealm`.  This is achieved by the line:

[source,ini]
----
securityManager.realms = $iniRealm
----

The file also (by way of example) include entries to setup an ldapRealm, but this is not wired in. For more information on LDAP, see link:./using-ldap.html[here].

Specifying `$iniRealm` means that the usernames/passwords, roles and permissions are read from the `shiro.ini` file itself.

* the users/passwords and their roles from the `[users]` sections;
* the roles are mapped to permissions in the `[roles]` section.


=== Users section

The `[users]` section lists users, passwords and their roles. For example:

[source,ini]
----
sven = pass, admin_role
dick = pass, user_role, analysis_role, self-install_role
bob  = pass, user_role, self-install_role
----

=== Roles section

The `roles` section lists roles and their corresponding permissions. For example:

[source,ini]
----
user_role = *:ToDoItems:*:*,\
            *:ToDoItem:*:*,\
            *:ToDoAppDashboard:*:*
analysis_role = *:ToDoItemAnalysis:*:*,\
            *:ToDoItemsByCategoryViewModel:*:*,\
            *:ToDoItemsByDateRangeViewModel:*:*
self-install_role = *:ToDoItemsFixturesService:install:*
admin_role = *
----

=== Permissions format

The permission format is configurable. The default format is:

[source,ini]
----
packageName:className:memberName:r,w
----

where:

* `memberName` is the property, collection or action name.
* `r` indicates that the member is visible
* `w` indicates that the member is usable (editable or invokable)

and where each of the parts of the permission string can be wildcarded using `*`.

Because these are wildcards, a '*' can be used at any level. Additionally, missing levels assume wildcards.  Thus:

[source]
----
com.mycompany.myapp:Customer:firstName:r,w   # view or edit customer's firstName
com.mycompany.myapp:Customer:lastName:r      # view customer's lastName only
com.mycompany.myapp:Customer:placeOrder:*    # view and invoke placeOrder action
com.mycompany.myapp:Customer:placeOrder      # ditto
com.mycompany.myapp:Customer:*:r             # view all customer class members
com.mycompany.myapp:*:*:r                    # view-only access for all classes in myapp package
com.mycompany.myapp:*:*:*                    # view/edit for all classes in myapp package
com.mycompany.myapp:*:*                      # ditto
com.mycompany.myapp:*                        # ditto
com.mycompany.myapp                          # ditto
*                                            # view/edit access to everything
----




==== Using the Enhanced Isis Permission Syntax

Shiro also allows the conversion to be mapped to alternative `Permission` instances; Isis provides its own `IsisPermission` which provides an extended and more flexible syntax.


Isis defines its own extended syntax for permissions, following the format:

[source,ini]
----
([!]?)([^/]+)[/](.+)
----

where:

* the optional `!` prefix indicates this permission is a vetoing permission
* the optional `xxx/` prefix is a permission group that scopes any vetoing permissions
* the remainder of the string is the permission (possibly wildcarded, with :rw as optional suffix)

For example:

[source,ini]
----
user_role   = !reg/org.estatio.api,\
              !reg/org.estatio.webapp.services.admin,\
              reg/* ; \
api_role    = org.estatio.api ;\
admin_role = adm/*
----

sets up:
* the user role with access to all permissions except those in `org.estatio.api` and `org.estatio.webapp.services.admin`
* the api_role with access to all permissions in `org.estatio.api`
* the admin_role with access to everything.

The permission group concept is required to scope the applicability of any veto permission. This is probably best explained by an example. Suppose that a user has both `admin_role` and `user_role`; we would want the `admin_role` to trump the vetos of the `user_role`, in other words to give the user access to everything. Because of the permission groups, the two `!reg/...` vetos in user_role only veto out selected permissions granted by the `reg/*` permissions, but they do not veto the permissions granted by a different scope, namely `adm/*`. The net effect is what we would want: that a user with both `admin_role` and `user_role` would have access to everything, irrespective of those two veto permissions of the `user_role`.

To tell Shiro to use the Isis permission format, add the following to `shiro.ini`:

[source,ini]
----
permissionResolver = org.apache.isis.security.shiro.authorization.IsisPermissionResolver
xxxRealm.permissionResolver = $permissionResolver
----

where `xxxRealm` is the realm to be configured.



== Multiple Realms

A more sophisticated approach is to use external realms. For example, to configure two text-based realms defined, `realm1` and `realm2`, we would define a `resourcePath` for each, in the form:

[source,ini]
----
realm1.resourcePath=classpath:webapp/realm1.ini
----

that is, the `src/main/resources/webapp/realm1.ini` file in the webapp project.

The security manager for the app would then be told to use these two realms:

[source,ini]
----
securityManager.realms = $realm1,$realm2
----

The the `[users]` and `[roles]` sections of `shiro.ini` would then be unused. Instead, you'll find these sections in both `realm1.ini` and `realm2.ini` (because both are coincidentally implementations of the same `org.apache.shiro.realm.text.IniRealm` class).




== Configuring Shiro to use LDAP

Isis ships with an implementation of http://shiro.apache.org[Apache Shiro]'s `Realm` class that allows user authentication and authorization to be performed against an LDAP server.

The configuration required in the `WEB-INF/shiro.ini` file is:

[source,ini]
----
contextFactory = org.apache.isis.security.shiro.IsisLdapContextFactory
contextFactory.url = ldap://localhost:10389
contextFactory.systemUsername = uid=admin,ou=system        # <1>
contextFactory.systemPassword = secret
contextFactory.authenticationMechanism = CRAM-MD5          # <2>
contextFactory.systemAuthenticationMechanism = simple

ldapRealm = org.apache.isis.security.shiro.IsisLdapRealm
ldapRealm.contextFactory = $contextFactory

ldapRealm.searchBase = ou=groups,o=mojo                    # <3>
ldapRealm.groupObjectClass = groupOfUniqueNames            # <4>
ldapRealm.uniqueMemberAttribute = uniqueMember             # <5>
ldapRealm.uniqueMemberAttributeValueTemplate = uid={0}

# optional mapping from physical groups to logical application roles
ldapRealm.rolesByGroup = \                                 # <6>
    LDN_USERS: user_role,\
    NYK_USERS: user_role,\
    HKG_USERS: user_role,\
    GLOBAL_ADMIN: admin_role,\
    DEMOS: self-install_role

ldapRealm.permissionsByRole=\                              # <7>
   user_role = *:ToDoItemsJdo:*:*,\
               *:ToDoItem:*:*; \
   self-install_role = *:ToDoItemsFixturesService:install:* ; \
   admin_role = *

securityManager.realms = $ldapRealm
----
<1> user accounts are searched using a dedicated service account
<2> SASL (CRAM-MD5) authentication is used for this authentication
<3> groups are searched under `ou=groups,o=mojo` (where `mojo` is the company name)
<4> each group has an LDAP objectClass of `groupOfUniqueNames`
<5> each group has a vector attribute of `uniqueMember`
<6> groups looked up from LDAP can optionally be mapped to logical roles; otherwise groups are used as role names directly
<7> roles are mapped in turn to permissions

The value of `uniqueMember` is in the form `uid=xxx`, with `xxx` being the uid of the user
* users searched under `ou=system`
* users have, at minimum, a `uid` attribute and a password
* the users credentials are used to verify their user/password

The above configuration has been tested against http://directory.apache.org/apacheds/[ApacheDS], v1.5.7. This can be administered using http://directory.apache.org/studio/[Apache Directory Studio], v1.5.3.



=== Using a shared role/perms path

As an alternative to injecting the `permissionsByRole` property, the role/permission mapping can alternatively be specified by injecting a resource path:

[source,ini]
----
ldapRealm.resourcePath=classpath:webapp/myroles.ini
----

where `myroles.ini` is in `src/main/resources/webapp`, and takes the form:

[source,ini]
----
 [roles]
 user_role = *:ToDoItemsJdo:*:*,\
             *:ToDoItem:*:*
 self-install_role = *:ToDoItemsFixturesService:install:*
 admin_role = *
----

This separation of the role/mapping can be useful if Shiro is configured to support multiple realms (eg an LdapRealm based one and also an TextRealm)


=== Active DS LDAP Configuration

The screenshot below shows the ApacheDS using Apache Directory Studio. The setup here was initially base on http://krams915.blogspot.co.uk/2011/01/ldap-apache-directory-studio-basic.html[this tutorial]. However, user accounts have been moved to a separate node.

==== Configure Mojo partition and nodes under Root

Create a partition in order to hold the mojo node (holding the groups)

image::{_imagesdir}/configuration/configuring-shiro/ldap/activeds-ldap-mojo-partition.png[ActiveDS LDAP Users]

Create the `ou=groups,o=mojo` hierarchy

image::{_imagesdir}/configuration/configuring-shiro/ldap/activeds-ldap-mojo-root-dse.png[ActiveDS LDAP Users]

Configure SASL authentication. This means that the checking of user/password is done implicitly by virtue of Isis connecting to LDAP using these credentials.

image::{_imagesdir}/configuration/configuring-shiro/ldap/activeds-ldap-sasl-authentication.png[ActiveDS LDAP Users]

In order for SASL to work, it seems to be necessary to put users under `o=system`. (This is why the setup is slightly different than the tutorial mentioned above).

image::{_imagesdir}/configuration/configuring-shiro/ldap/activeds-ldap-users.png[ActiveDS LDAP Users]

Configure the users into the groups.

image::{_imagesdir}/configuration/configuring-shiro/ldap/activeds-ldap-groups.png[ActiveDS LDAP Users]


== Shiro Realm Mappings

When configuring role based permission mapping, there can only be one of these entries per realm:

[source]
----
realm.groupToRolesMappings = ...
----

and

[source]
----
realm.roleToPermissionsMappings = ...
----

This forces you to put everything on one line for each of the above.

This is, unfortunately, a Shiro "feature". The only solution to this is to use "\" to separate the mappings onto separate lines in the file so that it is at least maintainable.

Use this technique for both group to roles mapping and role to permission mapping. If you use the '&#39; after the "," that separates the key:value pairs it is more readable.

If you repeat the entries above then it's "last one wins".

[WARNING]
====
Configuring a [roles] section instead doesn't work because that triggers Shiro to use the simple "INI" realm and not your defined realm.

In an enterprise environment you are most likely going to use either an LDAP realm or the realm that comes with the http://github.com/isisaddons/isis-module-security}[Isis addons' security] module (non-ASF); so the "simple" realm in Shiro isn't much use beyond prototyping work).
====



== Configuring Shiro to use the Security Isis Addons

The Isisaddons https://github.com/isisaddons/isis-module-security[security module] (not ASF) provides a complete
security subdomain for users, roles, permissions; all persisted as JDO domain objects. It also includes a Shiro realm
integration.

See the module's README for details of how to configure an existing app to use this module. Or, look at the the
Isisaddons https://github.com/isisaddons/isis-app-todoapp[todoapp example] (not ASF), which is preconfigured to use
the security module.



== Configuring Shiro for JDBC

Something like the following should do:

[source,ini]
----
builtInCacheManager = org.apache.shiro.cache.MemoryConstrainedCacheManager
securityManager.cacheManager = $builtInCacheManager

ps = org.apache.shiro.authc.credential.DefaultPasswordService
pm = org.apache.shiro.authc.credential.PasswordMatcher
pm.passwordService = $ps

aa = org.apache.shiro.authc.credential.AllowAllCredentialsMatcher
sm = org.apache.shiro.authc.credential.SimpleCredentialsMatcher

jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm
jdbcRealm.authenticationQuery = SELECT password from users where username = ?
jdbcRealm.userRolesQuery = select r.label from users_roles ur inner join roles r on ur.role_id = r.id where user_id = (select id from users where username = ?);
jdbcRealm.permissionsQuery=select p.permission from roles_permissions rp inner join permissions p on rp.permission_id = p.id where rp.role_id = (select id from roles where label = ?);
jdbcRealm.permissionsLookupEnabled=true

ds = com.mysql.jdbc.jdbc2.optional.MysqlDataSource
ds ...etc
securityManager.realms = $jdbcRealm
----

However, we would recommend you consider using the http://github.com/isisaddons/isis-module-security}[Isis addons' security] module instead of a home-grown JDBC solution.



== Accessing user/roles from domain objects

Generally speaking your domain objects should be agnostic of the user/roles that are interacting with them; applying security permissions is the responsibility of the framework.

Still, on very rare occasion you may have a need, in which case use the `DomainObjectContainer` service:

[source,java]
----
final UserMemento user = container.getUser();
final List<RoleMemento> roles = user.getRoles();
for (RoleMemento role : roles) {
    String roleName = role.getName();
    ...
}
----

Each role's `name` property encodes both the realm that provided the role, and the role identity itself.

For example, in the simpleapp, if logging in as `dick` with the following entries for `realm1`:

[source,ini]
----
dick = pass, user_role, analysis_role, self-install_role
----

then this corresponds to the roles "realm1:user_role", "realm1:self-install_role" and "realm1:analysis_role".

If using the Wicket viewer, then there will also be another role which is used internally (namely "org.apache.isis.viewer.wicket.roles.USER").



