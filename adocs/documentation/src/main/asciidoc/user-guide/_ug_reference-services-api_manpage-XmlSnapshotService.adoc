[[_ug_reference-services-api_manpage-XmlSnapshotService]]
= `XmlSnapshotService`
:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:_basedir: ../
:_imagesdir: images/

IMPORTANT: TODO




The 'wrapper' factory provides the ability to enforce business rules for programmatic interactions between domain objects. For example, if the calling object attempts to modify an unmodifiable property on the target object, then an exception will be thrown. Said another way: interactions are performed "as if" they are through the viewer.

This capability goes beyond enforcing the (imperative) constraints within the `hideXxx()`, `disableXxx()` and `validateXxx()` supporting methods; it also enforces (declarative) constraints such as those represented by annotations, eg `@MaxLength` or `@Regex`.

This capability is frequently used within xref:_ug_testing_integ-test-support[integration tests], but can also be used in production code. (There are analogies that can be drawn here with the way that JEE beans can interact through an EJB local interface).




== In a little more detail

The service works by returning a "wrapper" around a supplied domain object (a CGLIB proxy), and it is this wrapper that ensures hat the hide/disable/validate rules implies by the Isis programming model are enforced. The wrapper can be interacted with as follows:

* a get method for properties or collections
* a set method for properties
* an addTo or removeFrom method for collections
* any action

Calling any of the above methods may result in a (subclass of) `InteractionException` if the object disallows it. For example, if a property is annotated with `@Hidden` then a `HiddenException` will be thrown. Similarly if an action has a `validateXxx()` method and the supplied arguments are invalid then an `InvalidException` will be thrown.

In addition, the following methods may also be called:

* the `title()` method
* any `defaultXxx()` or `choicesXxx()` method

An exception will be thrown if any other methods are thrown.



== API

The `WrapperFactory` API is defined as follows:

[source,java]
----
@Hidden
public interface WrapperFactory {

    public static enum ExecutionMode { EXECUTE, NO_EXECUTE }  // <1>

    public <T> T wrap(T domainObject);                        // <2>
    public <T> T wrap(T domainObject, ExecutionMode mode);
    public <T> T unwrap(T possibleWrappedDomainObject);       // <3>

    public <T> boolean isWrapper(T possibleWrappedDomainObject);

    public List<InteractionListener> getListeners();
    public boolean addInteractionListener(InteractionListener listener);
    public boolean removeInteractionListener(InteractionListener listener);
    public void notifyListeners(InteractionEvent ev);

}
----
<1> `ExecutionMode` determines whether interactions with the wrapper are
 actually passed onto the underlying domain object.
<2> `wrap(...)` returns the wrapper around the underlying domain object (this
 does nothing if the object has already been wrapped)
<3> `unwrap(...)` returns the underlying domain object within the wrapper (this
 does nothing if the object is not a wrapper)

The API also provides the ability to register `InteractionListener`s with the
wrapper.




== Usage

The caller will typically obtain the target object (eg from some repository)
and then use the injected `WrapperFactory` to wrap it before interacting
with it.

For example:

[source,java]
----
public class CustomerAgent {

    public void refundOrder(final Order order) {
        final Order wrappedOrder = wrapperFactory.wrap(order);
        try {
            wrappedOrder.refund();
        } catch(InteractionException ex) {
            container.raiseError(ex.getMessage());
            return;
        }
    }

    ...
    @Inject
    WrapperFactory wrapperFactory;
    @Inject
    DomainObjectContainer container;
}
----

Here the ``Order``'s `refund()` action has various business logic. Rather than
re-implement this logic, the `CustomerAgent` wraps the order in order to interact with it.



== Hints and Tips

The xref:_ug_reference-services-spi_manpage-ExceptionRecognizer[`ExceptionRecognizer`]s provide the possibility
to remove the boilerplate; any `InteractionException` could be automatically
recognized and converted into a suitable message. The calling method could therefore
simply propogate the exception:

For example:

[source,java]
----
public class CustomerAgent {

    public void refundOrder(final Order order) throws InteractionException {
        wrapperFactory.wrap(order).refund();
    }

    ...
    private WrapperFactory wrapperFactory;    // injected
}
----

____

At the time of writing Isis does not provide an out-of-the-box implementation
of such an `ExceptionRecognizer`; but it should be simple enough to write oneâ€¦

____



== Registration

As of 1.6.0 this service is automatically on the classpath and registered (it is annotated with `@DomainService`).  Just ensure that the `o.a.i.core:isis-core-wrapper` Maven module is on your classpath.